import { Router } from 'express';
import { getDbPool } from '../config/db.js';
import { verifyToken } from './auth.js';
import { sendPaymentRequestEmail, sendStatusUpdateEmail } from '../services/emailService.js';

const router = Router();
const pool = getDbPool(); // Use single pool instance

router.get('/applications', verifyToken, async (req, res) => {
  console.log('\n=== GET /admin/applications ===');
  console.log('User:', req.user);
  console.log('Auth header:', req.headers.authorization);
  console.log('Query params:', req.query);

  // Verify admin role
  if (req.user.role !== 'admin') {
    console.log('❌ Access denied - user role:', req.user.role);
    return res.status(403).json({ 
      success: false, 
      message: 'Access denied. Admin role required.' 
    });
  }

  // Parse and validate query parameters
  const page = Math.max(1, parseInt(req.query.page) || 1);
  const limit = Math.max(1, Math.min(100, parseInt(req.query.limit) || 50));
  const status = req.query.status || 'all';
  const payment = req.query.payment || 'all';
  const search = req.query.search || '';
  const offset = (page - 1) * limit;

  // Build WHERE clause
  let whereConditions = [];
  let queryParams = [];
    
  if (status !== 'all') {
    whereConditions.push('status = ?');
    queryParams.push(status);
  }
    
  if (payment !== 'all') {
    whereConditions.push('payment_status = ?');
    queryParams.push(payment);
  }
    
  if (search) {
    whereConditions.push(`(
      candidate_name LIKE ? OR 
      email LIKE ? OR 
      mobile_no LIKE ? OR 
      course_name LIKE ?
    )`);
    const searchPattern = `%${search}%`;
    queryParams.push(searchPattern, searchPattern, searchPattern, searchPattern);
  }
    
  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
  
  try {
    // Get total count first
    console.log('Executing count query with params:', queryParams);
    const [countRows] = await pool.execute(`
      SELECT COUNT(*) as total 
      FROM temp_student 
      ${whereClause}
    `, queryParams);
    
    const totalCount = countRows[0].total;
    console.log('Total matching records:', totalCount);

    // Then get paginated results
    console.log('Executing main query with params:', [...queryParams, Number(limit), Number(offset)]);
    const [rows] = await pool.execute(`
      SELECT * FROM temp_student 
      ${whereClause}
      ORDER BY submitted_at DESC
      LIMIT ? OFFSET ?
    `, [...queryParams, limit, offset]);

    console.log(`Found ${rows.length} applications for current page`);

    // Transform data for frontend
    const results = rows.map(app => ({
      id: app.id?.toString() || '',
      candidateName: app.candidate_name || '',
      courseName: app.course_name || '',
      courseFee: app.course_fee || '₹0',
      email: app.email || '',
      mobileNo: app.mobile_no || '',
      fatherName: app.father_name || '',
      nationality: app.nationality || '',
      religionCaste: app.religion_caste || '',
      dateOfBirth: app.date_of_birth ? new Date(app.date_of_birth).toISOString().split('T')[0] : '',
      educationalQualification: app.educational_qualification || '',
      fullAddress: app.full_address || '',
      superintendentOfServer: app.superintendent_of_server || '',
      status: app.status || 'pending',
      paymentStatus: app.payment_status || 'unpaid',
      submittedAt: app.submitted_at || null,
      approvedAt: app.approved_at || null,
      rejectedAt: app.rejected_at || null,
      paidAt: app.paid_at || null,
      photoPath: app.photo_path || null
    }));

    // Send response
    res.json({
      success: true,
      applications: results,
      pagination: {
        page,
        limit,
        total: totalCount,
        pages: Math.ceil(totalCount / limit)
      }
    });
  } catch (error) {
    console.error('\n=== ERROR FETCHING APPLICATIONS ===');
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    console.error('Query params:', req.query);
    console.error('User:', req.user);
    
    const errorResponse = {
      success: false,
      message: 'Failed to fetch applications',
      error: process.env.NODE_ENV === 'development' 
        ? {
            message: error.message,
            stack: error.stack,
            code: error.code,
            sqlMessage: error.sqlMessage
          }
        : error.message
    };
    
    res.status(500).json(errorResponse);
  }
});

router.get('/stats', verifyToken, async (req, res) => {
  try {
    // Get application counts by status
    const [statusCounts] = await pool.execute(`
      SELECT 
        status,
        COUNT(*) as count
      FROM temp_student 
      GROUP BY status
    `);
    
    // Get payment status counts for approved applications
    const [paymentCounts] = await pool.execute(`
      SELECT 
        payment_status,
        COUNT(*) as count
      FROM temp_student 
      WHERE status = 'approved'
      GROUP BY payment_status
    `);
    
    // Calculate total revenue
    const [revenueResult] = await pool.execute(`
      SELECT 
        SUM(CAST(REPLACE(REPLACE(course_fee, '₹', ''), ',', '') AS UNSIGNED)) as total_revenue,
        COUNT(*) as paid_count
      FROM temp_student 
      WHERE payment_status = 'paid'
    `);
    
    // Convert results to stats object
    const statusCountsObj = {};
    statusCounts.forEach(row => {
      statusCountsObj[row.status] = row.count;
    });
    
    const paymentCountsObj = {};
    paymentCounts.forEach(row => {
      paymentCountsObj[row.payment_status] = row.count;
    });
    
    const stats = {
      pending: statusCountsObj.pending || 0,
      approved: statusCountsObj.approved || 0,
      rejected: statusCountsObj.rejected || 0,
      awaitingPayment: paymentCountsObj.unpaid || 0,
      fullyEnrolled: paymentCountsObj.paid || 0,
      totalRevenue: revenueResult[0]?.total_revenue || 0,
      paidCount: revenueResult[0]?.paid_count || 0
    };
    
    res.json({ success: true, stats });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Failed to fetch dashboard statistics', 
      error: error.message 
    });
  }
});

export default router;